# 题目

## 1. 买卖股票的最佳时机
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多>的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
### eg1
>输入: [7,1,5,3,6,4]

>输出: 7

>解释:在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。

### eg2 
>输入: [1,2,3,4,5]

>输出: 4

>解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。

### 答案
[答案](https://github.com/skyujilong/notebook/blob/master/algorithm/1.html)


## 2.给定一个整数数组，判断是否存在重复元素。

给定一个整数数组，判断是否存在重复元素。

如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。

### eg1
>输入: [1,2,3,1]
>输出: true

### eg2
>输入: [1,2,3,4]
>输出: false

### 答案
[答案](https://github.com/skyujilong/notebook/blob/master/algorithm/2.html)
### 注意
有时候提前排序后，效果会更好。


## 3. 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。
### eg1
>输入: [1,2,3,4,5,6,7] 和 k = 3
>输出: [5,6,7,1,2,3,4]
>解释:
>向右旋转 1 步: [7,1,2,3,4,5,6]
>向右旋转 2 步: [6,7,1,2,3,4,5]
>向右旋转 3 步: [5,6,7,1,2,3,4]
### 答案
[答案](https://github.com/skyujilong/notebook/blob/master/algorithm/3.html)
### 思路
出栈后直接插入头部。

## 4. 只出现一次的数字
给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

### eg1
>输入: [2,2,1]
>输出: 1

### eg2
>输入: [4,1,2,1,2]
>输出: 4
### 答案
[答案](https://github.com/skyujilong/notebook/blob/master/algorithm/4.html)
### 思路

^

查找其中唯一的一个不同的值，其他值都有重复的（出现两次）， 异或一边，重复的为0，剩下的值，就是唯一的那个值

## 5.两个数组的交集 II
给定两个数组，写一个方法来计算它们的交集。

**例如:**

给定 nums1 = [1, 2, 2, 1], nums2 = [2, 2], 返回 [2, 2].

**注意：**
>输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。
>我们可以不考虑输出结果的顺序。
### 答案
[答案](https://github.com/skyujilong/notebook/blob/master/algorithm/5.html)

## 6.有效的数独

判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。

>数字 1-9 在每一行只能出现一次。
>数字 1-9 在每一列只能出现一次。
>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。
### 答案
[答案](https://github.com/skyujilong/notebook/blob/master/algorithm/6.html)
## 7.旋转图像
给定一个 n × n 的二维矩阵表示一个图像。

将图像顺时针旋转 90 度。

**说明：**

你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。

### eg1
```
给定 matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

原地旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
```

### eg2
给定 matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

原地旋转输入矩阵，使其变为:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]

### 答案
[答案](https://github.com/skyujilong/notebook/blob/master/algorithm/7.html)
### 思路
关键在于 数字坐标换算的那几个 公式的推导，之后每次循环4个角的换位就行了。


## 8. 删除链表的倒数第N个节点
**示例：**
```
给定一个链表: 1->2->3->4->5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1->2->3->5.
```
**说明：**

给定的 n 保证是有效的。

**进阶：**

你能尝试使用一趟扫描实现吗？

### 答案
[答案](https://github.com/skyujilong/notebook/blob/master/algorithm/8.html)

### 思路
快慢指针， 慢指针，指向延后的n， 快指针正常循环的指针。

## 9. 合并两个有序链表
将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

**示例：**
>输入：1->2->4, 1->3->4
>输出：1->1->2->3->4->4

### 答案
[答案](https://github.com/skyujilong/notebook/blob/master/algorithm/9.html)

### 思路
依然是双指针策略。

## 10. 反转链表
反转一个单链表。

**示例:**
>输入: 1->2->3->4->5->NULL
>输出: 5->4->3->2->1->NULL
### 答案
[答案](https://github.com/skyujilong/notebook/blob/master/algorithm/10.html)
### 思路
你能拿到当前的元素以及下一个元素，做交换，并且记录下一个元素原本应该走的下一个指针的位置。

## 11.回文链表
什么是回文， 中央对称的数据结构 eg： [1,2,3,3,2,1];对折过来完全相同。

请判断一个链表是否为回文链表。


**示例 1:**
>输入: 1->2
>输出: false

**示例 2:**
>输入: 1->2->2->1
>输出: true

**进阶：**
>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？

### 答案 
[答案](https://github.com/skyujilong/notebook/blob/master/algorithm/11.html)
### 思路
逆转之后比对，能够完全相同， 进阶逆转一半，之后对比这一半的部分。

## 12.给定一个二叉树，判断其是否是一个有效的二叉搜索树。

一个二叉搜索树具有如下特征：
1. 节点的左子树只包含小于当前节点的数。
2. 节点的右子树只包含大于当前节点的数。
3. 所有左子树和右子树自身必须也是二叉搜索树。

### eg1
```
输入:
    2
   / \
  1   3
输出: true

```

### eg2
```
输入:
    5
   / \
  1   4
     / \
    3   6
输出: false
解释: 输入为: [5,1,4,null,null,3,6]。
     根节点的值为 5 ，但是其右子节点值为 4 。
```
### 答案 
[答案](https://github.com/skyujilong/notebook/blob/master/algorithm/12.html)
### 思路
**遍历**

这道题的关键点在于，一个节点的所有左侧的节点，包括左节点的所有右节点，都不能大于它本身的值；所有右侧节点，包括右节点的左节点，也都不能小于它本身的值。 

因此，节点（除了跟节点这样的特殊节点）其实上可以取值的范围是一个有限的区间。这就要求我们的递归函数需要3个参数，除了节点本身，还必须包括可以取得的最大值和最小值两个参数。

**中根遍历，返回有序队列**
判断是否是有序队列，要是不是就不是bst

先序遍历：中 -> 左 -> 右

中根遍历：左 -> 中 -> 右

后序遍历：左 -> 右 -> 中

[实现](https://github.com/skyujilong/notebook/blob/master/algorithm/13.html)

## 13.二叉树的层次遍历

给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。

>例如:

>给定二叉树: [3,9,20,null,null,15,7],

```
    3
   / \
  9  20
    /  \
   15   7
```
返回其层次遍历结果：
```
[
  [3],
  [9,20],
  [15,7]
]
```
### 答案
[答案](https://github.com/skyujilong/notebook/blob/master/algorithm/14.html)

### 思路
先序遍历，递归的时候多加一个参数，用于标定，当前的node需要放入那哪里！

## 14.对称二叉树
给定一个二叉树，检查它是否是镜像对称的。

例如，二叉树 [1,2,2,3,4,4,3] 是对称的。
```
    1
   / \
  2   2
 / \ / \
3  4 4  3
```

但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

```
    1
   / \
  2   2
   \   \
   3    3

```
### 答案
[答案](https://github.com/skyujilong/notebook/blob/master/algorithm/15.html)
### 思路
对称结构的树，可以单独考虑左子树与右子树，比较，之后左子树采用先序遍历，右子树采用后序遍历。进行对比就行了。

## 15.将有序数组转换为二叉搜索树

将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。

示例:
```
给定有序数组: [-10,-3,0,5,9],

一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：

      0
     / \
   -3   9
   /   /
 -10  5

```
### 答案
[答案](https://github.com/skyujilong/notebook/blob/master/algorithm/16.html)
### 思路
左中右， 左<中<右，有序安放数组的中间下标对应的值。


## 16.爬楼梯
假设你正在爬楼梯。需要 n 步你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**注意：** 给定 n 是一个正整数。

**示例 1：**
```
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 步 + 1 步
2.  2 步
```
**示例 2：**
```
输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 步 + 1 步 + 1 步
2.  1 步 + 2 步
3.  2 步 + 1 步
```
### 答案
[答案](https://github.com/skyujilong/notebook/blob/master/algorithm/17.html)
### 解析
[解析](https://www.sohu.com/a/153858619_466939)

比方说有10个台阶， 我们有几种方式能够登顶那？ 因为我们只能一次跨两个台阶，或者一个台阶， 这样我们最后一步跨出的时候，自然就是在台阶9
或者台阶8。往前推的话， 我们想上台阶9，那么我们最后一步就是从台阶8或者台阶7跨上去的， 这样我们假定上台阶9有f(9)种方法，上台阶8有f(8)种方法。这样上到台阶10的方法就有 f(10) = f(9) + f(8);

思考一下边界值：当我们上第一个台阶的时候只有1种方法， 迈一步， 上第二阶的时候我们可以有两种方案 1，1 或者 2。

因此f(1)= 1,f(2) = 2;

之后通过递归就可以解出来上到n阶台阶，一共有多少中方案。但是在计算的时候，可以使用map来缓存我们的数值，防止反复的重复计算。

要点：
*最优子结构*、*边界值*、*注意值的备份，防止重复计算*


### 总结
1. 构造问题所对应的过程。
2. 思考过程的最后一个步骤，看看有哪些选择情况。
3. 找到最后一步的子问题，确保符合“子问题重叠”，把子问题中不相同的地方设置为参数。
4. 使得子问题符合“最优子结构”。
5. 找到边界，考虑边界的各种处理方式。
6. 确保满足“子问题独立”，一般而言，如果我们是在多个子问题中选择一个作为实施方案，而不会同时实施多个方案，那么子问题就是独立的。
7. 考虑如何做备忘录。
8. 分析所需时间是否满足要求。
9. 写出转移方程式。

## 17.最大子序和
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
**示例:**
```
输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```
### 答案
[答案](https://github.com/skyujilong/notebook/blob/master/algorithm/18.html)
### 解析
动态规划的一道题，记得找最优子表达式，大范围变小进行思考。

## 18.买卖股票的最佳时机
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。

注意你不能在买入股票前卖出股票。

**eg1:**
```
输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
```
**eg2:**
```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```
## 答案
[答案](https://github.com/skyujilong/notebook/blob/master/algorithm/19.html)

## 打家劫舍
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。
**示例 1:**
```
输入: [1,2,3,1]
输出: 4
解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```
**示例 2:**
```
输入: [2,7,9,3,1]
输出: 12
解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```
### 答案
[答案](https://github.com/skyujilong/notebook/blob/master/algorithm/19.html)
### 解析
```
//最优子表达式
f(n) = max{f(n-2)+nums[n],f(n-1)}
```