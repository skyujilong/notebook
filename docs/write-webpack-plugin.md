# how to write webpack plugin(如何写一个webpack的插件)

作为一个webpack的忠实拥护者，怎么也得给webpack推广一下是吧。所以就有了这篇文章，众所周知，webpack有两个强力的东西，一个是loader，应对于处理各种文件类型的。还有另外一个就是plugin了，这个东西怎么说那，应该是个万金油，干什么都行，比loader还要强大。

## 基本使用

### 同步PLUGIN如下代码：

```javascript
    function HelloWorldPlugin(options){
        //为外部初始化该plugin时的参数
    }
    HelloWorldPlugin.prototype.apply = function (compliler) {
        //compliler对象是webpack的对象这个很重要，后面讲解作用
        compliler.plugin('done',() => {
            console.log('hello world');//该log日志，会在webpack构建项目结束后运行
        });
    };
    module.exports = HelloWorldPlugin;
```

### 异步PLUGIN如下代码：

```javascript
    function HelloWorldPlugin(options){
        //为外部初始化该plugin时的参数
    }
    HelloWorldPlugin.prototype.apply = function (compliler) {
        //compliler对象是webpack的对象这个很重要，后面讲解作用
        compliler.plugin('done',(compilation, cb) => {
            setTimeout(() => {
                console.log('hello world');//在webpack 构建完毕后的300ms后打印hello world
                cb();//通知webpack 该组件已经运行完毕
            },300);
        });
    };
    module.exports = HelloWorldPlugin;
```

### Compliler & Compilation

为什么说plugin会很强大那？<br>
就是因为webpack给plugin注入的两个对象，compliler 和 compliation。<br>
现在让我们来讲讲这两个对象。

1. compliler:该对象，在webpack运行的时候，只创建一次，该对象会包含有你所有的配置信息。请用该对象来访问你配置的webpack环境。
2. compliation:该对象，包含有compliler,该对象在每次文件更改时都会创建。请用该对象来访问你需要的webpack资源。比如说，更改一个文件的内容，请用该对象去找到你需要更改的文件，并予以更改内容。

### compliler.plugin方法

该方法是一个注册方法，注册在那些事件上，会调用什么样的方法。

```javascript
Tapable.prototype.plugin = function plugin(name, fn) {
if(Array.isArray(name)) {
    name.forEach(function(name) {
        this.plugin(name, fn);
    }, this);
    return;
}
if(!this._plugins[name]) this._plugins[name] = [fn];
else this._plugins[name].push(fn);
};
```

其中可以运行的状态如下：

1. run 新创建一个compilation，这个事件不会再watch模式下被调用。
1. watch-run 在watch模式下新创建一个compilation。
1. compilation 当compilation被创建的时候会调用该事件。
1. normal-module-factory 当NormalModuleFactory被创建的时候，会调用该事件。
1. compile Compiler开始编译的时候调用，在watch于非watch模式下均会调用。
1. make prefetch对象的addEntry与prefetch方法调用的时候。
1. after-compile 当编译过程结束，并且module封装完毕的时候调用。下一步将会进行输出编译后的内容。
1. emit 输出编译后的内容。这是最后能够借助webpack的io去修改内容的方法。
1. after-emit 编译已经输出所有编译后的内容，会调用该事件。
1. done 所有的事情都做完的时候。
1. failed 在watch模式下一个compilation发生错误的时候。
1. after-plugins 所有的plugin都添加到complier内的时候。
1. after-resolvers 所有的plugin都添加到resolvers内的时候。

常用的都是上面这些。还有一些是编译后的产生的事件。[链接](http://webpack.github.io/docs/plugins.html)

### 遍历资源文件
```JavaScript
function MyPlugin() {}

MyPlugin.prototype.apply = function(compiler) {
  compiler.plugin('emit', function(compilation, callback) {

    // Explore each chunk (build output):
    compilation.chunks.forEach(function(chunk) {
      // Explore each module within the chunk (built inputs):
      chunk.modules.forEach(function(module) {
        // Explore each source file path that was included into the module:
        module.fileDependencies.forEach(function(filepath) {
          // we've learned a lot about the source structure now...
        });
      });

      // Explore each asset filename generated by the chunk:
      chunk.files.forEach(function(filename) {
        // Get the asset source for each file generated by the chunk:
        var source = compilation.assets[filename].source();
      });
    });

    callback();
  });
};

module.exports = MyPlugin;

```

### 图片压缩处理demo
```javascript
    const _ = require('loadsh');
    function TinyPNGPlugin(){

    }
    TinyPNGPlugin.prototype.apply = function (compiler) {
        let reg = new RegExp('\.(jpg|jpeg|png)$','i');
        compiler.plugin('emit', (compilation, cb) => {
            _.cach(compilation.assets,(val,fileName) => {
                if(reg.exec(fileName)){
                    //TODO 通过val 这个buffer去进行图片的压缩，然后在替换回来即可了
                }
            });
        });
    };
    module.exports = TinyPNGPlugin;
```
**详细的内容，欢迎查看我的webpack图片压缩组件，tinypng-webpack-plugin。**

[项目地址](https://www.npmjs.com/package/tinypng-webpack-plugin)
