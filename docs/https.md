# HTTPS
## http是不安全的
http协议传输都是明文传输，中间有劫持的话，用户的信息就会被盗，eg：密码。

## HTTP 与 HTTPS的区别
http 架构

| 架构 |
| - |
| HTTP |
| TCP/IP |

https 架构

| 架构 |
| - |
| HTTP |
| SSL/TLS |
| TCP/IP |

整体来看https就是 在http的基础上，增加了 ssl/tls 。

**HTTPS = HTTP + SSL/TLS**

## HTTPS的核心
1. 对称加密
1. 非对称加密

## 对称加密
对称加密(也叫私钥加密)指加密和解密使用相同密钥的加密算法，安全性全靠，随机密钥是否被攻破。
eg:
```javascript
let content = 'your context';
let secKey = 'youkey';//根据算法的需求，自己定义的一个随机的密钥
let result = AES(content,secKey); // 生成加密后的字符串， eg:SLDFJOI@($#(@^$()))
let resultContent = AES(result,secKey);// 返回 your context 内容
```

优点：

算法运行速度快，占用资源小。

缺点：

安全可靠性，不太好。 解密加密的密钥一致。

## 非对称加密
非对称加密算法需要两个密钥：公开密钥（publickey:简称公钥）和私有密钥（privatekey:简称私钥）。公钥与私钥是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。

eg:

```javascript
let publicKey = 'adfafafafasfafaffsf';
let secKey = 'sssssssssss';
//当然上面的都是算法生成的一对 公钥，私钥
let userContent = 'your content';
let result = RSA(userContent,publicKey);// 生成 加密后：aslfladajfaoaf;aaa;dsoij
let resultContent = RSA(result,secKey);// 反向解析出 your content内容

```

优点：

加密效果比价好，没有私钥解析出来很难。

缺点：

执行算法占用资源多，耗时比对称加密要大很多。

## https核心原理

为什么说上面的两种加密算法，上面的加密算法就是https的加密核心。

### 思考一下。 如果单独用对称加密来加密http内容，会是什么效果？

因为http是明文传送内容，我们如何该传递我们对称加密的密钥？

### 思考一下。 如果单独用非对称加密http内容，会是什么效果？

采用非对称加密，如何降低，服务器的压力？毕竟非对称加密，很耗费性能。

### 综合两者的优点

既然我们又想要非对称加密的安全，以及对称加密的快速。我们直接俩都用就行了。

这就是组成ssl层的核心，俩算法我都用。

过程是这样的。

| 客户端 | 过程 | 服务器 |
| - | - | - |
| 发送请求 | =》 | 接受请求 |
| 接受返回 | 《= | 返回服务器的公钥 |
| 拿公钥加密一个随机字符串 | =》 | 接受请求 |
| 接受返回 | 《= | 拿私钥解析出来随机字符串 |
| 上一次生成的随机字符串对称加密内容 | =》 | 接受请求 |
| 接受返回 | 《= | 通过之前拿到的随机字符串解密加密内容，在返回对称加密算法加密的返回值 |

反复重复上面的 对称加密 解密进行传递数据！ 

## 详细

![ssl图](https://github.com/skyujilong/notebook/blob/master/src/ssl.png)

1. 客户端 发送，支持的加密算法，以及随机数a
2. 服务器 接受， 客户端的加密算法，以及随机数a， 并返回随机数b + 自己的数字证书 + 选择的对称加密算法
3. 客户端解析数字证书，拿证书中解析出来的服务器公钥，加密随机数a,b,以及新生成的c，发送给服务器。
4. 服务器用自己的私钥解析客户端公钥生成的加密内容，得到客户端对称加密的密钥。
5. 反复通过对称加密的公钥加密发送内容，通过公钥解密内容。

## 证书
为什么要用证书？

eg:
客户端的网络被劫持的情况下

| 客户端 | 过程 | 劫持客户端的服务器(B) | 过程 | 正确的服务器(A) |
| - | - | - | - | - |
| 发送请求,带有支持的对称算法 | -> | 收到请求，发送 | -> | 接受到请求 |
| 接受请求，拿到公钥 | <- | 接受服务器A的公钥，返回给客户端B的公钥 | <- | 返回服务器A公钥 |

通过上述单个流程，可以知道整个过程因为缺少第三方验证，导致不安全。

如果有三方证书。

上述过程就不一样了。

在客户端获取公钥，是在证书内解析出来的。我们可以验证CA证书的正确性。

>数字证书中除了包含加密之后的服务器公钥，权威机构的信息之外，还包含了证书内容的签名(先通过Hash函数计算得到证书数字摘要，然后用权威机构私钥加密数字摘要得到数字签名)，签名计算方法以及证书对应的域名。

*客户端收到证书之后：*

>使用权威机构的公钥解密数字证书，得到证书内容（服务器的公钥）以及证书的数字签名，然后根据证书上描述的计算证书签名的方法计算一下当前证书的签名，与收到的签名作对比，如果一样，表示证书一定是服务器下发的，没有被中间人篡改过。因为中间人虽然有权威机构的公钥，能够解析证书内容并篡改，但是篡改完成之后中间人需要将证书重新加密，但是中间人没有权威机构的私钥，无法加密，强行加密只会导致客户端无法解密，如果中间人强行乱修改证书，就会导致证书内容和证书签名不匹配。所以证书签名就能判断证书是否被篡改

>再考虑证书被掉包的情况：中间人同样可以向权威机构申请一份证书，然后在服务器给客户端下发证书的时候劫持原证书，将自己的假证书下发给客户端，客户端收到之后依然能够使用权威机构的公钥解密证书，并且证书签名也没问题。但是这个时候客户端还需要检查证书中的域名和当前访问的域名是否一致。如果不一致，会发出警告！

## 参考

[看完还不懂HTTPS我直播吃翔](https://zhuanlan.zhihu.com/p/25976060)

[深入揭秘HTTPS安全问题&连接建立全过程](https://blog.csdn.net/mbugatti/article/details/53536924)

[图解SSL/TLS协议](http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html)